<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:base="en">
	<title>Simeon Steward</title>
	<subtitle>Simple Portfolio website to show off my projects</subtitle>
	<link href="https://simeonsteward.github.io/feed/feed.xml" rel="self"/>
	<link href="https://simeonsteward.github.io/"/>
	<updated>2023-08-29T00:00:00Z</updated>
	<id>https://simeonsteward.github.io/</id>
	<author>
		<name>Simeon Steward</name>
		<email></email>
	</author>
	
	<entry>
		<title>Dominion Simulator Project</title>
		<link href="https://simeonsteward.github.io/blog/dominion_simulator/"/>
		<updated>2023-08-29T00:00:00Z</updated>
		<id>https://simeonsteward.github.io/blog/dominion_simulator/</id>
		<content type="html">&lt;p&gt;#Dominion
I learned dominion at a fairly young age, and was highly competive in my teens. In 2018, I took fourth place in the world championship, and at one point for a couple of hours I was the highest rated player on the leaderboard. This passion for dominion has combined with my desire to write software and I began creating a dominion simulator.
The idea behind this dominion simulator, is that the user can create two strategies, and the program will quickly simulate 10s of thousands of games between them to let the user know how much better a given strategy is compared to another. This project is not the first dominion simulator, and is inspired by Geronimoo&#39;s dominion simulator.
Dominion is a deck builder created by Donald X. Vaccarino in 2009. Each game 10 cards are choosen from a massive pool of 366 cards. Because every game has different cards, strategies that exist on one kingdom simply don&#39;t exist in others because the cards are different. Because of this, it is helpful to know the relative strength of many different strategies. As a human who has played thousands of games, I have developed a decent intuition on what is good, but it is really helpful to have numbers to either back me up or change my mind so that people can become even better at dominion.&lt;/p&gt;
&lt;h3 id=&quot;why-rust&quot; tabindex=&quot;-1&quot;&gt;Why Rust?? &lt;a class=&quot;header-anchor&quot; href=&quot;https://simeonsteward.github.io/blog/dominion_simulator/&quot;&gt;#&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;For this project, I choose to use rust because&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The type system is very expressive, allowing me to model dominion in a more complete way, and in a way that ensures that I implement functionality for every card of a type&lt;/li&gt;
&lt;li&gt;Memory safety is guaranteed&lt;/li&gt;
&lt;li&gt;Rust is fast&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;this-project-has-to-do-implement&quot; tabindex=&quot;-1&quot;&gt;This project has to do implement &lt;a class=&quot;header-anchor&quot; href=&quot;https://simeonsteward.github.io/blog/dominion_simulator/&quot;&gt;#&lt;/a&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Game engine
&lt;ul&gt;
&lt;li&gt;Drawing, discarding, playing, buying, playing and trashing cards&lt;/li&gt;
&lt;li&gt;Manage player state&lt;/li&gt;
&lt;li&gt;Check game end conditions&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Strategy
&lt;ul&gt;
&lt;li&gt;Buy strategy&lt;/li&gt;
&lt;li&gt;Play strategy&lt;/li&gt;
&lt;li&gt;Save and load strategies&lt;/li&gt;
&lt;li&gt;User create strategies&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;All 366 cards need to be implemented&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;extensions-to-this-project&quot; tabindex=&quot;-1&quot;&gt;Extensions to this project &lt;a class=&quot;header-anchor&quot; href=&quot;https://simeonsteward.github.io/blog/dominion_simulator/&quot;&gt;#&lt;/a&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;User interface for ease of use&lt;/li&gt;
&lt;li&gt;Support to pit multiple strategies against each other to create a table of dominion strategies with their relative strengths&lt;/li&gt;
&lt;li&gt;Performance optimization&lt;/li&gt;
&lt;li&gt;Support to simulate strategies from a certain game state&lt;/li&gt;
&lt;li&gt;Support to auto create strategies
&lt;ul&gt;
&lt;li&gt;Auto pit them against each other&lt;/li&gt;
&lt;li&gt;Find best strategies for a kingdom&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;progress&quot; tabindex=&quot;-1&quot;&gt;Progress &lt;a class=&quot;header-anchor&quot; href=&quot;https://simeonsteward.github.io/blog/dominion_simulator/&quot;&gt;#&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;I started this project in the June 2023, and have the basic game engine implemented, and am working on implementing user creating, loading and saving strategies.&lt;/p&gt;
&lt;h3 id=&quot;lessons-learned&quot; tabindex=&quot;-1&quot;&gt;Lessons learned &lt;a class=&quot;header-anchor&quot; href=&quot;https://simeonsteward.github.io/blog/dominion_simulator/&quot;&gt;#&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Rust has a very fussy compiler. This is both a good and a bad thing. On the bright side, because it is so fussy, when you get the code to pass the compiler, it usually works how you intend it to, another great feature of the compiler is that the error messages often tell you exactly what you need to do to fix the problem.
One downside of rust is that borrow checker can make it hard to use reuse references that could be easily done in a garbage collected language, or a manual allocated language. This project has helped me learn to deal with the borrowed refrences and lifetimes. Rust&#39;s type system and match statements are really enjoyable to use and ensure that all cases of enums are handled which is a commonly used throughout the project.&lt;/p&gt;
</content>
	</entry>
	
	<entry>
		<title>RIP Protocol Project</title>
		<link href="https://simeonsteward.github.io/blog/rip_protocol/"/>
		<updated>2023-08-23T00:00:00Z</updated>
		<id>https://simeonsteward.github.io/blog/rip_protocol/</id>
		<content type="html">&lt;h1 id=&quot;implementing-the-rip-routing-protocol-in-python&quot; tabindex=&quot;-1&quot;&gt;Implementing the RIP Routing Protocol in Python &lt;a class=&quot;header-anchor&quot; href=&quot;https://simeonsteward.github.io/blog/rip_protocol/&quot;&gt;#&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;During my study abroad in New Zealand, one of my computer networking courses involved implementing the Routing Information Protocol (RIP) in Python. RIP is a distance-vector routing protocol used to exchange routing information between routers.&lt;/p&gt;
&lt;p&gt;For this project, I worked in collaboration with Adam Venroy to build out an incomplete implementation of RIP v2 as specified in RFC 2453. Our implementation handles the core functionality namely:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Sending and receiving RIP response messages&lt;/li&gt;
&lt;li&gt;Processing routing table updates&lt;/li&gt;
&lt;li&gt;Managing router timeouts and triggered updates&lt;/li&gt;
&lt;li&gt;Poison reverse to prevent routing loops&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Some limitations of our implementation:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;No authentication&lt;/li&gt;
&lt;li&gt;No support for route tags, subnet masks, or next hops&lt;/li&gt;
&lt;li&gt;Uses port numbers from the config file instead of ip addresses&lt;/li&gt;
&lt;li&gt;Does not handle RIP queries&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;implementation-details&quot; tabindex=&quot;-1&quot;&gt;Implementation Details &lt;a class=&quot;header-anchor&quot; href=&quot;https://simeonsteward.github.io/blog/rip_protocol/&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Each router in our RIP implementation is simulated by a separate Routing Demon process configured from a file specifying the router ID, ports, neighbors, and timers. The Routing Demon opens UDP sockets on its input ports to receive RIP packet updates. Internally, it uses a distance vector table stored in a nested dictionary to track the costs to each known destination router. This table gets populated and updated as RIP responses are received. The demon also maintains its own routing table containing the next hop, interface, metric, and timers for each route. It leverages Python&#39;s struct library to encode and decode the raw RIP packet byte arrays. And it implements internal timers to manage timeout of stale routes and triggering rapid updates when the topology changes. The core routing logic and control plane mechanisms were built from scratch in Python without any external libraries. Each Routing Demon serves as an autonomous router emulation able to receive and propagate routing updates through the exchange of RIP packets.&lt;/p&gt;
&lt;h2 id=&quot;key-components&quot; tabindex=&quot;-1&quot;&gt;Key Components &lt;a class=&quot;header-anchor&quot; href=&quot;https://simeonsteward.github.io/blog/rip_protocol/&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Some of the key components we implemented:&lt;/p&gt;
&lt;p&gt;RIP Message Processing - Parses incoming RIP response packets and processes the routing table entries to update the local routing table. This includes validating metrics and router IDs.&lt;/p&gt;
&lt;p&gt;Triggered Updates - Monitors routing changes and can trigger an immediate update to neighbors rather than waiting for the next periodic update. This speeds up convergence.&lt;/p&gt;
&lt;p&gt;Timers - Manages time-based behaviors like timing out stale routes and garbage collecting old deletions.&lt;/p&gt;
&lt;p&gt;Routing Table - Stores routes, metrics, next hops, and timers in a dictionary structure.&lt;/p&gt;
&lt;p&gt;Packet Encoding - Uses Python struct library to encode and decode RIP packet byte arrays.
Lessons Learned&lt;/p&gt;
&lt;h1 id=&quot;experience-gained&quot; tabindex=&quot;-1&quot;&gt;Experience Gained &lt;a class=&quot;header-anchor&quot; href=&quot;https://simeonsteward.github.io/blog/rip_protocol/&quot;&gt;#&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;Working on this project gave me hands-on experience with:&lt;/p&gt;
&lt;p&gt;Implementing a real networking protocol from its RFC specification
Packet encoding and parsing
Managing router state and time-based behaviors
Optimizing convergence and stability in a distributed routing algorithm
Python&lt;/p&gt;
&lt;p&gt;Let me know if you have any other questions! I&#39;m happy to discuss the project in more depth.&lt;/p&gt;
</content>
	</entry>
</feed>
